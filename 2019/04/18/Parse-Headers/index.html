<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Contents Recap of Part 1: The Code for Part 2 Load the Libraries and Set File Path The Header Parser function The Encoding Problem Account for Duplicate Values in Headers Recap of Part 1: In my...">
        <meta name="keywords" content="python, tutorial">
        <link rel="icon" href="../../../../favicon.ico">

        <title>End-to-End Data Analysis Project: Part 2. Parsing the Headers - Sonny's Blog</title>

        <!-- Stylesheets -->
        <link href="../../../../theme/css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../theme/css/fonts.css" rel="stylesheet">
        <link href="../../../../theme/css/nest.css" rel="stylesheet">
        <link href="../../../../theme/css/pygment.css" rel="stylesheet">
        <!-- /Stylesheets -->

        <!-- RSS Feeds -->
        <link href="https://sonnycruz.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Sonny's Blog Full Atom Feed" />
        <link href="https://sonnycruz.github.io/feeds/python.atom.xml" type="application/atom+xml" rel="alternate" title="Sonny's Blog Categories Atom Feed" />
        <!-- /RSS Feeds -->

        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
        <![endif]-->



    </head>

    <body>

        <!-- Header -->
    <div class="header-container" style="background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('../../../../images/art-artistic-background-247676.jpg'); background-position: center; background-size: cover;">

            <!-- Static navbar -->
            <div class="container">
                <div class="header-nav">
                    <div class="header-logo">
                        <a class="pull-left" href="../../../../"><img class="mr20" src="../../../../images/blank.png" alt="logo">Sonny's Blog</a>
                    </div>
                    <div class="nav pull-right">
                            <a  href="../../../../pages/about-me.html">About Me</a>
                    </div>
                </div>
            </div>
            <!-- /Static navbar -->

            <!-- Header -->
    <!-- Header -->
    <div class="container header-wrapper">
        <div class="row">
              <div class="col-lg-12">
                  <div class="header-content">
                      <h1 class="header-title">End-to-End Data Analysis Project: Part 2. Parsing the Headers</h1>
                      <p class="header-date"> <a href="../../../../author/sonny-torres.html">Sonny Torres</a>, Thu 18 April 2019,  <a href="../../../../category/python.html">Python</a></p>
                      <div class="header-underline"></div>
                      <div class="clearfix"></div>
                      <p class="pull-right header-tags">
                          <span class="glyphicon glyphicon-tags mr5" aria-hidden="true"></span>
<a href="../../../../tag/python.html">python</a>, <a href="../../../../tag/tutorial.html">tutorial</a>                      </p>
                  </div>
              </div>
        </div>
    </div>
    <!-- /Header -->
            <!-- /Header -->

        </div>
        <!-- /Header -->


        <!-- Content -->
    <div class="container content">
        <div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#recap-of-part-1" id="id1"><strong>Recap of Part 1:</strong></a></li>
<li><a class="reference internal" href="#the-code-for-part-2" id="id2"><strong>The Code for Part 2</strong></a></li>
<li><a class="reference internal" href="#load-the-libraries-and-set-file-path" id="id3"><strong>Load the Libraries and Set File Path</strong></a></li>
<li><a class="reference internal" href="#the-header-parser-function" id="id4"><strong>The Header Parser function</strong></a></li>
<li><a class="reference internal" href="#the-encoding-problem" id="id5"><strong>The Encoding Problem</strong></a></li>
<li><a class="reference internal" href="#account-for-duplicate-values-in-headers" id="id6"><strong>Account for Duplicate Values in Headers</strong></a></li>
</ul>
</div>
<div class="section" id="recap-of-part-1">
<h2><a class="toc-backref" href="#id1"><strong>Recap of Part 1:</strong></a></h2>
<p>In my <a class="reference external" href="../../../../2018/12/23/Getting-Data/">previous post</a> I explained and showed how I scraped CMBS loan data from an HTML file downloaded from the <a class="reference external" href="https://www.sec.gov/Archives/edgar/data/1013611/000152153611000217/q1100154_fwpa1-jpm.htm">SEC.gov website</a> in order to refine my web scraping skills and acquire a dataset that was copyright free. A practical advantage of this dataset is that it is incredibly messy and often data &quot;in the wild&quot; requires a number of formatting steps before any analysis can be done.</p>
<p>After the numerous HTML tables were scraped for their header data and table data, I saved each table and table header to a CSV file. Now I have two folders, one for headers and one for tables, full of csv files. Below is an image of the &quot;headers&quot; folder the script in my previous post created as well as all of the header files that were moved to it.</p>
<img alt="header files" src="/images/files_in_header_folder.jpg" />
</div>
<div class="section" id="the-code-for-part-2">
<h2><a class="toc-backref" href="#id2"><strong>The Code for Part 2</strong></a></h2>
<p>Below is all of the code that parses the header data and that I will be covering in this blog post.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">main_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\Username\Desktop\End to End Data Analysis Project\header&quot;</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">main_dir</span><span class="p">)</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;*header.csv&#39;</span>
<span class="n">all_header_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">is_word</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\w&#39;</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="n">value</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">load_headers</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>

    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">header_rows</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">header_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">new_line</span> <span class="o">=</span> <span class="p">[</span><span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFKD&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span>
        <span class="n">header_dict</span><span class="p">[</span><span class="n">header_rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_line</span>
        <span class="n">header_rows</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">main_header</span> <span class="o">=</span> <span class="n">header_dict</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">header_dict</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">main_header_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_header</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row_ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">header_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                    <span class="n">word_index</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">word_text</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">is_word</span><span class="p">(</span><span class="n">word_text</span><span class="p">)</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="n">word_text</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">header_dict</span><span class="p">[</span><span class="n">row_ind</span><span class="p">][</span><span class="n">word_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">word_text</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;parsed&#39;</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">header_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ISO-8859-1&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="n">number</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header_rows</span><span class="p">)],</span>
                     <span class="n">na_values</span><span class="o">=</span><span class="s1">&#39;empty&#39;</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span>

<span class="n">all_header_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; header.csv&#39;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">load_headers</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
        <span class="n">all_header_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">all_header_values</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
<span class="n">frame</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;frame.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="load-the-libraries-and-set-file-path">
<h2><a class="toc-backref" href="#id3"><strong>Load the Libraries and Set File Path</strong></a></h2>
<p>Below are the python libraries necessary to run the script. The <tt class="docutils literal">main_dir</tt> variable is the path to the folder that contains the CSV header files as shown in the image above. I then used the <tt class="docutils literal">os.chdir</tt> method from the <tt class="docutils literal">os</tt> module to change to that directory. This is just a convenient way that I like to direct my python scripts to the correct folder but filepaths can be handled in many different ways.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">main_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\Username\Desktop\End to End Data Analysis Project\header&quot;</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">main_dir</span><span class="p">)</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;*header.csv&#39;</span>
<span class="n">all_header_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">is_word</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\w&#39;</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="n">value</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
</pre></div>
<p>Because I am only interested in files that end with the word &quot;header&quot; and have the file extension &quot;.csv&quot;, I use <tt class="docutils literal">*header.csv</tt>, the asterisk being a character used in the <a class="reference external" href="https://docs.python.org/3.6/library/re.html">Regular Expressions library</a> which means that the filename can start with anything as long as it ends with &quot;header.csv&quot;.</p>
<p>The <tt class="docutils literal">pattern</tt> and <tt class="docutils literal">all_header_files</tt> variables are not necessary in this case because the folder <em>only</em> contains header files and <tt class="docutils literal">os.chdir</tt> changed the current directory to the folder with the files but I included these variables and their explanations below because this is a common file manipulation technique that I have found very useful.</p>
<p>The header files will be contained in the list <tt class="docutils literal">all_header_files</tt>. The <tt class="docutils literal">os.path.join</tt> method simply joins the path provided, <tt class="docutils literal">main_dir</tt>, and the pattern <tt class="docutils literal">header.csv</tt>. Basically the join method appends &quot;header.csv&quot; to the main folder path. In order to utilize the pattern the way I wanted, that is, to catch any file that ends with &quot;header.csv&quot;, I used the glob library to expand this pattern to generalize to all files that match the pattern. The list comprehension creates a list of each file's absolute path and <tt class="docutils literal">os.path.basename</tt> extracts only the filename and extension from the absolute path. Again, a simple <tt class="docutils literal">for</tt> loop to iterate over each file would suffice in this case, but I included the <tt class="docutils literal">pattern</tt> and <tt class="docutils literal">all_header_files</tt> as a reference for myself and others when looking to do common file manipulation operations. See the <tt class="docutils literal">os.path</tt> <a class="reference external" href="https://docs.python.org/3.6/library/os.path.html">documentation</a> for more.</p>
<p><tt class="docutils literal">is_word</tt>, as you might have guessed, searches for words in a given string. The raw character string <tt class="docutils literal"><span class="pre">r'\w'</span></tt> uses the Regular Expressions module to search for any alphanumeric character.</p>
</div>
<div class="section" id="the-header-parser-function">
<h2><a class="toc-backref" href="#id4"><strong>The Header Parser function</strong></a></h2>
<p>The remainder of this blog post will cover the bulk of the script, which is the <tt class="docutils literal">load_headers</tt> function. This function loads in each CSV file, one at a time, parses and cleans the header data and saves the modified headers as a new file. This is necessary because the headers, when concatenated with the table data, would be horribly misaligned and would cascade down one to three rows if they were not parsed prior to joining the data.</p>
<p>The function <tt class="docutils literal">load_headers</tt> first accepts a filename (for example &quot;2 header.csv&quot;). Below, the <tt class="docutils literal">open</tt> function creates a <a class="reference external" href="https://docs.python.org/3.6/library/functions.html#open">file object</a> to be read by the <tt class="docutils literal">csv</tt> <a class="reference external" href="https://docs.python.org/3.6/library/csv.html">module</a> with the <tt class="docutils literal">.reader</tt> method.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_headers</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>

    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
<p>Similar to my first post, I iterate over each line of the data one at a time, horizonatally, across each row of data and again utilize a dictionary data container to easily have access to any portion of the data (e.g. a certain row or a certain word in a given row). Each header row will have an index value associated with it and each header will be stored as a list in the <tt class="docutils literal">header_dict</tt> dictionary.</p>
<div class="highlight"><pre><span></span><span class="n">header_rows</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">header_dict</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="section" id="the-encoding-problem">
<h2><a class="toc-backref" href="#id5"><strong>The Encoding Problem</strong></a></h2>
<p>Before iterating over each header row of each CSV file to create dictionaries of the header rows, I had to make changes to the text data's encoding.</p>
<p>The concept of encoding has always been elusive to me until I found this <a class="reference external" href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">great article</a>, written by the Stack Overflow CEO, Joel Spolsky.</p>
<p>Here are my oversimplified definitions of what I have learned about encoding.</p>
<ol class="arabic simple">
<li>Encoding: The process of assigning letters, numbers and symbols to a specially formatted number that a computer can efficiently store in memory and output as a letter, number or symbol. The notated numbers are converted to bits by a computer and stored in memory. This process is complicated and involves low-level coding and computer science expertise to fully appreciate.</li>
<li>Character Set: A set of characters that are encoded under some character encoding standard like <a class="reference external" href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> or Unicode.</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>: A standardized system of characters (text, numbers, symbols etc.) and their corresponding &quot;integer&quot; called <a class="reference external" href="https://en.wikipedia.org/wiki/Code_point">code points</a>. These integers are notated in a special way and look like this U+0639 (U+ stands for Unicode and 0639 is a hexadecimal).</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> : a character encoding system that encode all valid Unicode code points using one to four 8-bit bytes. For example, the first 128 characters of the Unicode character set are each encoded with on 8-bit byte. The next group of approximately 1,900 characters require 2 8-bit bytes.</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252 or CP-1252</a>: A single byte character encoding of the Latin alphabet.</li>
</ol>
<p>Python's default encoding is UTF-8 but the SEC website is encoded with Windows-1252. This mismatch of encodings created frustrating problems I did not understand. I would parse the header data, export to CSV and find strange characters all over the CSV file when I opened it in excel. The root of the problem is succinctly illustrated below in a chart, specifically the highlighted portion, I found on <a class="reference external" href="https://www.i18nqa.com/debug/utf8-debug.html">this website</a>.</p>
<img alt="utf encoding chart" src="/images/utf_encodings.jpg" />
<p>In the image above you can see there are not only different &quot;inputs&quot; (code points) but different outputs. The solution for this problem involved using the <tt class="docutils literal">unicodedata</tt> library and its <tt class="docutils literal">.normalize</tt> method. Using the chart's terminology, the 'NFKD' supplied value in the code below simply converts the <em>actual</em> character result with the <em>expected</em> character result under the Unicode standard. In this case, a blank space also known as a <a class="reference external" href="https://en.wikipedia.org/wiki/Non-breaking_space">non-breaking space</a> is the expected and desired value. This solution made it so that instead of a bunch of &quot;ÂÂÂÂÂÂÂÂ&quot;'s appearing in my excel file, they were blank cells like they were supposed to be before the encoding problem. The blank cells are important because they play an integral part in keeping the entire document's format consistent.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">new_line</span> <span class="o">=</span> <span class="p">[</span><span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFKD&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span>
    <span class="n">header_dict</span><span class="p">[</span><span class="n">header_rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_line</span>
    <span class="n">header_rows</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">main_header</span> <span class="o">=</span> <span class="n">header_dict</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">header_dict</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">main_header_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_header</span><span class="p">)</span>
</pre></div>
<p>The code above then creates the variable <tt class="docutils literal">main_header</tt>, which is the bottom header row and its associated length. This bottom header row is important because some headers have text that spans down 2-3 rows while others do not and the bottom header row is the only consistent row that will be used to align other header rows above it.</p>
</div>
<div class="section" id="account-for-duplicate-values-in-headers">
<h2><a class="toc-backref" href="#id6"><strong>Account for Duplicate Values in Headers</strong></a></h2>
<p>The next section of the <tt class="docutils literal">load_headers</tt> function involves iterating over the dictionary of header values, counting the instances of each word in a given header row and appending a random number from 0-9 to the word if it is not a unique word. This is important for a reason I will explain in the next couple of steps.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row_ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">header_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">word_index</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">word_text</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_word</span><span class="p">(</span><span class="n">word_text</span><span class="p">)</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="n">word_text</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">header_dict</span><span class="p">[</span><span class="n">row_ind</span><span class="p">][</span><span class="n">word_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">word_text</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
</pre></div>
<p>Below, ''filename'' is a variable that will store the new filename for the new CSV file that will contain the parsed header rows. <tt class="docutils literal">filename</tt> is created by simply using the existing filename, stripping '.csv' from the end of the file, appending '_parsed' to the end and adding the '.csv' file extension back on the filename string.</p>
<div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;parsed&#39;</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span>
</pre></div>
<p>After the headers are normalized to Unicode encoding and the duplicates are accounted for, I use the common pythonic way of writing files, utilizing the <tt class="docutils literal">with open</tt> technique to write the <tt class="docutils literal">header_dict</tt> values (lists of header data) to a CSV file.</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">header_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
<p>Finally, I load the <em>new</em> CSV header file into a Pandas Dataframe for further editing. <strong>The reason I had to account for the duplicate values in the headers involves loading a MultiIndex with Pandas' ``read_csv`` method</strong>. Because I want to merge all of the header rows into a single header row, I need to be able to access the header rows and their values individually by loading the headers as a MultiIndex. The normal output of a MultiIndex is an array of tuples, which contain the string values for each row in a column. Below is an example of of how the Multindex is organized.</p>
<div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([(</span><span class="s1">&#39;col1_row1&#39;</span><span class="p">,</span> <span class="s1">&#39;col1_row2&#39;</span><span class="p">,</span> <span class="s1">&#39;col1_row3&#39;</span><span class="p">),</span>
       <span class="p">(</span><span class="s1">&#39;col2_row1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2_row2&#39;</span><span class="p">,</span> <span class="s1">&#39;col2_row3&#39;</span><span class="p">),</span>
       <span class="p">(</span><span class="s1">&#39;col3_row1&#39;</span><span class="p">,</span> <span class="s1">&#39;col3_row2&#39;</span><span class="p">,</span> <span class="s1">&#39;col3_row3&#39;</span><span class="p">)])</span>
</pre></div>
<p>This feature of Pandas is useful because you can access any given value you want by accessing the string values within the tuples. Utilizing the tuples for the MultiIndex was my intention with the code below.</p>
<div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ISO-8859-1&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="n">number</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header_rows</span><span class="p">)],</span>
                 <span class="n">na_values</span><span class="o">=</span><span class="s1">&#39;empty&#39;</span><span class="p">)</span>
</pre></div>
<p>My method of gluing together multiple header rows into one header row was achieved by iterating over each tuple value, putting a space in between each word and then stripping away the white space on the ends of each header by using the <tt class="docutils literal">.strip</tt> method. Lastly, the <tt class="docutils literal">load_headers</tt> function returns the dataframe with the cumulative changes made thus far.</p>
<div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

<span class="k">return</span> <span class="n">df</span>
</pre></div>
<p>However, <em>when gluing the header rows together I noticed that my results for duplicate values came out strange</em>. But only for duplicate values in a given row. My IPython session below illustrates why.</p>
<img alt="tuples vs strings" src="/images/headers_tuples_strings.JPG" />
<p>In the image above, you can see that the majority of header columns are tuples, as expected, but columns 8-10, 12 and 13 are <em>string</em> values. For reasons I do not know, Pandas will load duplicate values in a MultiIndex not as tuples but as string values. So, when I iterate over each header column like they are tuples as I did with the <tt class="docutils literal">' <span class="pre">'.join(col)...</span></tt> list comprehension above, I ended up iterating over each character in those string values causing columns with duplicate values to look like this:</p>
<div class="highlight"><pre><span></span><span class="p">(</span> <span class="s1">&#39; L e a s e &#39;</span> <span class="p">,</span>   <span class="s1">&#39; E x p i r a t i o n &#39;</span> <span class="p">)</span> <span class="o">.</span> <span class="mi">1</span>
</pre></div>
<p>In the output above, there is a space in between each letter caused by the <tt class="docutils literal">' '.join</tt> list comprehension. The iteration method worked fine on the column values that were tuples but created the undesired result when the column was actually a string value. Luckily, I found a way to differentiate the duplicate values by appending a random number as show earlier in this post.</p>
<p>Finally, a simple for loop iterates over the files in the directory, utilizes the <tt class="docutils literal">load_headers</tt> function, appends each header file's headers to a single list <tt class="docutils literal">all_header_values</tt>, concatenates the resulting list using the <tt class="docutils literal">pd.concat</tt> method and saves the parsed headers into a single CSV file which I called 'frame.csv'</p>
<div class="highlight"><pre><span></span><span class="n">all_header_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; header.csv&#39;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">load_headers</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
        <span class="n">all_header_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">all_header_values</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
<span class="n">frame</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;frame.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
<p>The reason I iterated over the range of numbers I did was because there were 19 files in the directory and I wanted to iterate over <em>every other</em> file because duplicate sets of headers were &quot;skipped&quot; by saving them as a blank CSV file as shown in the code in my first post.</p>
<p>Now that all the data is gathered and the headers have been parsed and combined into a single, neat row, the only thing left to produce a single table of data is to concatenate the table files and their respective headers, which I will do in my next post.</p>
</div>



        
    </div>
        <!-- /Content --> 

        <!-- Footer -->
        <div class="footer gradient-2">
            <div class="container footer-container ">
                <div class="row">
                    <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
                        <div class="footer-title"></div>
                        <ul class="list-unstyled">
                            <li><a href="https://sonnycruz.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"></a></li>
                        </ul>
                    </div>
                    <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
                        <div class="footer-title"></div>
                        <ul class="list-unstyled">
                            <li><a href="" target="_blank"></a></li>
                            <li><a href="#" target="_blank"></a></li>
                        </ul>
                    </div>
                    <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
                        <div class="footer-title"></div>
                        <ul class="list-unstyled">
                            <li><a href="https://www.linkedin.com/in/sonny-torres-6738b780" target="_blank">LinkedIn</a></li>
                            <li><a href="https://github.com/sonnycruz" target="_blank">Github</a></li>
                            <li><a href="https://twitter.com/sonnyctorres" target="_blank">Twitter</a></li>
                            <li><a href="#" target="_blank"></a></li>
                        </ul>
                    </div> 
                    <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
                        <p class="pull-right text-right">
                            <small><em>Proudly powered by <a href="http://docs.getpelican.com/" target="_blank">pelican</a></em></small><br/>
                            <small><em>Theme and code by <a href="https://github.com/molivier" target="_blank">molivier</a></em></small><br/>
                            <small></small>
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <!-- /Footer -->
    </body>
</html>