<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sonny's Blog - python</title><link href="https://sonnycruz.github.io/" rel="alternate"></link><link href="https://sonnycruz.github.io%5Cfeeds/python.atom.xml" rel="self"></link><id>https://sonnycruz.github.io/</id><updated>2018-12-23T07:33:00-06:00</updated><entry><title>Getting Data: Parsing HTML Files</title><link href="https://sonnycruz.github.io%5C2018/12/23/Getting-Data/" rel="alternate"></link><published>2018-12-23T07:33:00-06:00</published><updated>2018-12-23T07:33:00-06:00</updated><author><name>Sonny Torres</name></author><id>tag:sonnycruz.github.io\2018,2018-12-23:/12/23/Getting-Data/</id><summary type="html">&lt;p class="first last"&gt;Parsing a messy HTML file, downloaded from SEC.gov, and formatting it into a tabular dataset.&lt;/p&gt;
</summary><content type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introduction" id="id1"&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-this-project-came-about" id="id2"&gt;How this Project Came About&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-goal" id="id3"&gt;The Goal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what-to-expect-in-this-post" id="id4"&gt;What to Expect in this Post&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-tools-used" id="id5"&gt;The Tools Used&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#understanding-the-data" id="id6"&gt;&lt;strong&gt;Understanding the Data&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-data-source" id="id7"&gt;The Data Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what-is-cmbs" id="id8"&gt;What is CMBS?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#table-arrangement" id="id9"&gt;Table Arrangement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-html-structure" id="id10"&gt;The HTML Structure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#import-libraries-and-make-soup" id="id11"&gt;&lt;strong&gt;Import Libraries and Make Soup&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#grab-the-tables" id="id12"&gt;&lt;strong&gt;Grab the Tables&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-headers" id="id13"&gt;&lt;strong&gt;The Headers&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#good-headers" id="id14"&gt;Good Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bad-headers" id="id15"&gt;Bad Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-bad-side-of-good-headers" id="id16"&gt;The Bad Side of Good Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#infinite-nest" id="id17"&gt;Infinite Nest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#file-writer-function" id="id18"&gt;&lt;strong&gt;File Writer Function&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-bulk-of-the-script" id="id19"&gt;&lt;strong&gt;The Bulk of the Script&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-data-container-objects" id="id20"&gt;&lt;strong&gt;The Data Container Objects&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-1-iterate-over-each-table-and-each-row" id="id21"&gt;&lt;strong&gt;Part 1: Iterate over each Table and each Row&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-this-project-came-about"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id2"&gt;How this Project Came About&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;After working with Python to manipulate and analyze commercial loan data at my job, I wanted to start a data analysis blog where I could showcase my programming projects. However, the loan data I used at my job was subject to copyright protection. Luckily, the Securities and Exchange Commission website publishes similar data.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-goal"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;The Goal&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My goals for this project was the following:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;Get data&lt;/strong&gt; : Acquire commercial property loan data that I could freely use and publish on my blog in order to showcase some of my Python projects in future posts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automation&lt;/strong&gt; : Rather than ask my blog readers to copy and paste or &amp;quot;just download&amp;quot; the data, I wanted to create an automation script to retrieve the messy data from scratch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Practice&lt;/strong&gt;: Refine my programming and data cleaning skills by challenging myself to create a script that could generalize, with minimal modifications, and work on similar SEC postings.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-to-expect-in-this-post"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;What to Expect in this Post&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I will be parsing a messy HTML file with multiple tables and writing the data to a single CSV file. The post covers the following:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;A quick walkthrough of the data source and what the data covers.&lt;/li&gt;
&lt;li&gt;A walk through of the layout of the web page and the HTML structure.&lt;/li&gt;
&lt;li&gt;A break down of a handful of helper functions that are utilized in the main script.&lt;/li&gt;
&lt;li&gt;A break down of the main script.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I created visualizations where I felt they would help, included several website links throughout to reference some fundamental programming concepts and aimed to explain everything in detail while trying to keep things as simple as possible.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-tools-used"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;The Tools Used&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The code utilizes the main Python library as well as &lt;a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/"&gt;BeautifulSoup&lt;/a&gt; and &lt;a class="reference external" href="https://docs.python.org/3.7/library/re.html"&gt;Regular Expressions&lt;/a&gt; .&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="understanding-the-data"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;&lt;strong&gt;Understanding the Data&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-data-source"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;The Data Source&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To retrieve the HTML file that I used, you can download the HTML file hosted on my github page or you can visit the SEC url and press Ctrl + S to save the file as an HTML document.&lt;/p&gt;
&lt;p&gt;Right-click on the link &amp;amp; save as an html file: &lt;a class="reference external" href="https://sonnycruz.github.io/files/JPC11C05.html"&gt;Download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL: &lt;a class="reference external" href="https://www.sec.gov/Archives/edgar/data/1013611/000152153611000217/q1100154_fwpa1-jpm.htm"&gt;https://www.sec.gov/Archives/edgar/data/1013611/000152153611000217/q1100154_fwpa1-jpm.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To view the HTML, open the file or website in your browser and right click anywhere on the webpage and click &amp;quot;Inspect&amp;quot;. Ctrl+Shift+I is the windows shortcut to do this.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-cmbs"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;What is CMBS?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Commercial Mortgage-Backed Securities (&lt;a class="reference external" href="https://www.investopedia.com/terms/c/cmbs.asp"&gt;CMBS&lt;/a&gt;) are &lt;a class="reference external" href="https://www.pimco.com/en-us/resources/education/everything-you-need-to-know-about-bonds"&gt;Bonds&lt;/a&gt; backed by a group of commercial mortgages. The bonds are then sold to investors on the open market and thus subject to SEC regulations. The document with the data is what is called the &lt;strong&gt;Annex A&lt;/strong&gt; section of a prospectus. A prospectus is meant to advertise and inform potential investors of the investment opportunity and the Annex A section tabulates the loans and commercial properties that serve as collateral for the loans. The data used at my job was a monthly updated snapshot of thousands of loans, while the SEC data I utilized reflects a smaller group of loans that were just originated, before any payments were made. The SEC data being used in this post covers one securitized pool, or group, of CMBS loans. There are 44 loans and 214 properties.&lt;/p&gt;
&lt;p&gt;The individual CMBS data points included in the dataset fall into four main categories:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Mortgage data (Loan Balance, Interest Rate, Maturity Date, etc.)&lt;/li&gt;
&lt;li&gt;Commercial property data (Location, Property Type, Square Feet, etc.)&lt;/li&gt;
&lt;li&gt;Securitization Data (characteristics that describe the Securitized structure such as a given loan's loan balance as a proportion of the entire pool/group of loans).&lt;/li&gt;
&lt;li&gt;Performance Data (historical financial performance of the commercial properties).&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="table-arrangement"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;Table Arrangement&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The dataset is split into many different tables that are vertically lined up on one page. Because I wanted tabular data, I had to first understand how the various tables were organized in order to put them together. The charts below illustrate how the first four tables are arranged and how they must be transformed in order to fit together as a single dataset like a CSV or excel file. For simplification, the visual only includes 10 Commercial Properties.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We can see four tables with various headers, columns and rows (See Legend). Each column, which includes a data point for every row, is broken up into two separate tables. So, Properties 1-5 are in Table 1 and Table 2 lists the other 5 properties, Properties 6-10. Similarly, Table 4 is a continuation of Table 3.&lt;/p&gt;
&lt;img alt="" src="/images/sec1.png" /&gt;
&lt;img alt="" src="/images/Legend.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Tables 1 &amp;amp; 2 need to be glued together and 3 &amp;amp; 4 need to be glued together, both along the horizonal axis. Notice how the excess headers, (the grey-shaded headers in the above figure) have been eliminated.&lt;/p&gt;
&lt;img alt="" src="/images/sec2.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The pairs of tables will be joined together on their respective vertical axes. Because &amp;quot;Prop1, Prop2..etc.&amp;quot; represents not only commercial properties in the pool of mortgages, but also the indices for each table, we will have to go back and delete the duplicate indices that will result from merging the tables in this way.&lt;/p&gt;
&lt;img alt="" src="/images/sec4.png" /&gt;
&lt;p&gt;When iteratively joining every 4 tables in this way, the result will be a single tabular dataset, albeit with plenty of clean up work left to do. The tricky table layout actually pales in comparison, for me, to the complexity of parsing the header rows and creating rules to account for blank spaces in the table, which I will attempt to explain later in this post.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-html-structure"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;The HTML Structure&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before writing any code, I first had to carefully examine the HTML structure (I often used the command Ctrl+Shift+I to view the HTML followed by Ctrl+F to find what I was looking for and sometimes writing down the results on notebook paper). The key to understanding the HTML, for me, was understanding the &lt;a class="reference external" href="https://www.w3schools.com/tags/tag_html.asp"&gt;HTML tag&lt;/a&gt; structure, as well as what characteristics makes certain kinds of data unique, specifically what &lt;a class="reference external" href="https://www.w3schools.com/html/html_attributes.asp"&gt;HTML tag attributes&lt;/a&gt; make a given row of data identifiable as being a header row, a data row or a row to skip.&lt;/p&gt;
&lt;p&gt;The HTML Table Basics
1. &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tags define a table of data.
2. &lt;tt class="docutils literal"&gt;&amp;lt;tr&amp;gt;&lt;/tt&gt; tags define the rows in a table.
3. &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tags define a cell in table.&lt;/p&gt;
&lt;p&gt;More on HTML table structures &lt;a class="reference external" href="https://www.w3schools.com/html/html_tables.asp"&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="import-libraries-and-make-soup"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;&lt;strong&gt;Import Libraries and Make Soup&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here are the libraries I used for this task.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;bs4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;BeautifulSoup&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;bs4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Tag&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;csv&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I used Python's &lt;tt class="docutils literal"&gt;with open&lt;/tt&gt; syntax to create a file object which gave me the detail needed for parsing the HTML file at a granular, line by line, element by element level.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;sec&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;soup&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BeautifulSoup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;lxml&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="grab-the-tables"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;&lt;strong&gt;Grab the Tables&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Each table of data is encased in &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tags in the HTML document. However, there were tables that I did not want, specifically the &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tags that consist of only footnotes (at bottom of HTML document). These tables all had a &lt;tt class="docutils literal"&gt;'border'&lt;/tt&gt; attribute within the main table tag (see below).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Tables have no 'border' attribute&lt;/strong&gt;&lt;/p&gt;
&lt;img alt="" src="/images/good_table.JPG" /&gt;
&lt;p&gt;&lt;strong&gt;Unwanted Tables have 'border' attribute&lt;/strong&gt;&lt;/p&gt;
&lt;img alt="" src="/images/bad_table.JPG" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I used a list comprehension to grab all the tables by targeting the &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; HTML tag and excluded all &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tags with a &lt;tt class="docutils literal"&gt;'border'&lt;/tt&gt; tag attribute. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;soup.findAll('table')&lt;/span&gt;&lt;/tt&gt; returns a &lt;tt class="docutils literal"&gt;bs4.element.ResultSet&lt;/tt&gt; which is a list of &lt;tt class="docutils literal"&gt;bs4.element.Tag&lt;/tt&gt; objects - the &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tags.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tables&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
     &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;soup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;table&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;border&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrs&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;table_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-headers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;&lt;strong&gt;The Headers&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Because the table headers came with their own unique challenges, I wanted to keep track of the headers and table rows separately. I first needed to see what distinguished the headers in the HTML. Embedded in the &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tag, there is a &lt;tt class="docutils literal"&gt;&amp;lt;font&amp;gt;&lt;/tt&gt; tag with a &lt;tt class="docutils literal"&gt;style&lt;/tt&gt; attribute. I found that &lt;em&gt;all&lt;/em&gt; header cells contained the word &lt;tt class="docutils literal"&gt;bold&lt;/tt&gt; in the attribute value for the &lt;tt class="docutils literal"&gt;style&lt;/tt&gt; attribute (see below), while the the table rows never contain the &lt;tt class="docutils literal"&gt;bold&lt;/tt&gt; tag attribute.&lt;/p&gt;
&lt;img alt="" src="/images/header_td.JPG" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="good-headers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;Good Headers&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The function I made to identify headers has two parameters, &lt;tt class="docutils literal"&gt;tag&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;keyword&lt;/tt&gt; . The &lt;tt class="docutils literal"&gt;tag&lt;/tt&gt; parameter accepts an HTML tag to search for the keyword &amp;quot;bold&amp;quot; within the font's style attribute. The BeautifulSoup &lt;tt class="docutils literal"&gt;.find()&lt;/tt&gt; method accepts, in this example, the tag to find, &amp;quot;font&amp;quot; and the tag attribute/value pair, &amp;quot;style&amp;quot; and &amp;quot;bold&amp;quot;. &lt;tt class="docutils literal"&gt;.find()&lt;/tt&gt; returns only the first instance of the match it finds, which is sufficient for determining a header row. When the function below does &lt;em&gt;not&lt;/em&gt; find the &amp;quot;bold&amp;quot; keyword, it will return a None object, which is important to know as we continue building rules.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keyword&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bold&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# returns bs4.element.Tag or None&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;font&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;style&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keyword&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bad-headers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;Bad Headers&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;However, I wanted to &lt;em&gt;exclude&lt;/em&gt; some of the header rows. Some of the tables have a hierarchal index structure where one large header row describes a group of columns. See the &amp;quot;Hotel Operating Statistics&amp;quot; header which I wanted to exclude for simplification.&lt;/p&gt;
&lt;img alt="" src="/images/trythisheadercropped.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The above &amp;quot;unwanted header&amp;quot; is differentiated in the HTML from the &amp;quot;wanted headers&amp;quot; by having a large &amp;quot;colspan&amp;quot; attribute value. The &amp;quot;colspan&amp;quot; attribute tells us how many columns a given data point spans across. The HTML below shows that the &amp;quot;Hotel Operating Statistics&amp;quot; header has a colspan value of 15.&lt;/p&gt;
&lt;img alt="" src="/images/colspan15.JPG" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To be clear, in this HTML file, &lt;em&gt;all&lt;/em&gt; colspan attribute values are associated with headers but not all headers are associated with a colspan attribute.&lt;/p&gt;
&lt;p&gt;I then searched the HTML document manually in my browser, using Ctrl+f, for &amp;quot;colspan&amp;quot;. There are only 20 instances of &amp;quot;colspan&amp;quot; in the entire HTML document. I saw that the highest colspan value for a &lt;em&gt;good&lt;/em&gt; header was 2.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So, any colspan values greater than 2 will be disregarded and not written to the CSV file.
The fucntion &lt;tt class="docutils literal"&gt;unwanted_header()&lt;/tt&gt; will accept the &lt;tt class="docutils literal"&gt;&amp;lt;tr&amp;gt;&lt;/tt&gt; tag as the argument for the &lt;tt class="docutils literal"&gt;tag&lt;/tt&gt; parameter and the &lt;tt class="docutils literal"&gt;colspan_limit&lt;/tt&gt; default value is set to 2, as a good header can have a colspan value of 2. &lt;tt class="docutils literal"&gt;unwanted_header()&lt;/tt&gt; searches the &lt;tt class="docutils literal"&gt;&amp;lt;tr&amp;gt;&lt;/tt&gt; tag for any &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tag that has a &lt;tt class="docutils literal"&gt;colspan&lt;/tt&gt; tag attribute with a numerical string value. The &lt;tt class="docutils literal"&gt;re.compile()&lt;/tt&gt; method is a Regular Expressions method that creates a Regular Expression object with a pattern that can be searched for. The 'r' tells Python not to interpret any backslash characters (for example &amp;quot;n&amp;quot; is interpreted by Python as a newline) and to let BeautifulSoup interpret the backslashes with its own syntax rules. In this case, &lt;tt class="docutils literal"&gt;\d+&lt;/tt&gt; will be interpreted by BeautifulSoup to mean &amp;quot;any numerical digit occuring at least one time&amp;quot;. If the &lt;tt class="docutils literal"&gt;colspan&lt;/tt&gt; attribute is present in one of the row's &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tags then the &lt;tt class="docutils literal"&gt;colspan_obj&lt;/tt&gt; will exists as a Tag object and the &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statement is &lt;tt class="docutils literal"&gt;True&lt;/tt&gt;. If the specific tag is not found, the object will be a None value and the &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statement is &lt;tt class="docutils literal"&gt;False&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;colspan_val&lt;/tt&gt; is a variable assigned to the colspan value, the string value for the &lt;tt class="docutils literal"&gt;colspan&lt;/tt&gt; tag and it is converted to an integer by using the &lt;tt class="docutils literal"&gt;int()&lt;/tt&gt; function. &lt;tt class="docutils literal"&gt;colspan_obj&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;bs4.element.Tag&lt;/tt&gt; object, which means the tag's attributes can be accessed like a dictionary like this &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;colspan_obj['colspan']&lt;/span&gt;&lt;/tt&gt;.  Finally, if the integer is larger than 2, the function will return True and if there is no &lt;tt class="docutils literal"&gt;colspan_obj&lt;/tt&gt; or if the integer is equal to or less than 2, the function will return &lt;tt class="docutils literal"&gt;False&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;unwanted_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;colspan_limit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;colspan_obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;td&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;colspan&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\d+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;colspan_obj&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_obj&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;colspan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;colspan_limit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then I created a simple function to test for the previous two function's criteria at once.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_good_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;unwanted_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-bad-side-of-good-headers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;The Bad Side of Good Headers&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before, I mentioned that there are &lt;em&gt;some&lt;/em&gt; good headers with a colspan value &lt;em&gt;equal&lt;/em&gt; to 2. These headers need to be identified in order to correct a problem they present.&lt;/p&gt;
&lt;p&gt;In the image below, the figure labeled &amp;quot;HTML&amp;quot; reflects how the website's tags are organized when a header value spans across 2 columns. A header value with a colspan attribute value of 2 is enclosed in &lt;strong&gt;1&lt;/strong&gt; &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt;, while the rows below the header have &lt;em&gt;2&lt;/em&gt; &amp;lt;td&amp;gt; tags (one yellow, one blue). This is 2-to-1 arrangement is not visible on the website and aligns appropriately in the HTML output, however, because my script iterates over every &amp;lt;td&amp;gt; tag and writes each one to a cell in my CSV file, I ran into a cell alignment problem illustrated in the figure below labeled &amp;quot;CSV Result&amp;quot;.&lt;/p&gt;
&lt;img alt="" src="/images/cell_align2.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To identify the good headers with a colspan value of 2, I created a boolean function that returns True when all &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tags span the same number of columns, 1 each, and returns False when they do not. The &lt;tt class="docutils literal"&gt;colspan_dict&lt;/tt&gt; is a dictionary object where the keys are the row numbers of a table and the values are lists with the colspan values. By using a list comprehension that calls the &lt;tt class="docutils literal"&gt;max()&lt;/tt&gt; function on every list of colspan values, I can create a list of values that describe the maximum colspan value per row. The function returns &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; when the largest colspan value does not equal 1.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cells_same_colspan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# reduce colspan dict values&lt;/span&gt;
    &lt;span class="n"&gt;max_colspan_per_row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_colspan_per_row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Below is an example of what the &lt;tt class="docutils literal"&gt;colspan_dict&lt;/tt&gt; object would look like if a table had two rows and had a single colspan value equal to 2 in the second row.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# COLSPAN_DICT object&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;

&lt;span class="c1"&gt;# where the dict keys are table rows (including headers)&lt;/span&gt;
&lt;span class="c1"&gt;# and the dict values are lists containing&lt;/span&gt;
&lt;span class="c1"&gt;# each data point&amp;#39;s colspan value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If the function &lt;tt class="docutils literal"&gt;cells_same_colspan()&lt;/tt&gt; , returns False, the row with the colspan value equal to 2 must be modified to align the table columns properly.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="infinite-nest"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;Infinite Nest&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like the book &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Infinite_Jest"&gt;Infinite Jest&lt;/a&gt;, where the author's writing style can yield a page-long sentence with several tangential thoughts nested within the main thought, this project involved an abundance of nesting in order to complete the task in the best way I knew how. The data structures I used to track each piece of data (rows, data points, colspan values etc.), as well as the control structure of the main loop display this layered characteristic.&lt;/p&gt;
&lt;p&gt;The dictionary object, &lt;tt class="docutils literal"&gt;nested_colspan_dict&lt;/tt&gt; , is a record of all rows for a given table, the index value of the data points in the row, and the colspan values in each for each data point. This object will be used to store all the information needed to make cell alignment changes to the actual cells of data. Below is an example of what the &lt;em&gt;nested&lt;/em&gt; object will look like.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# NESTED_COLSPAN_DICT object&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]}&lt;/span&gt;

&lt;span class="c1"&gt;# where the dict keys are table rows&lt;/span&gt;
&lt;span class="c1"&gt;# and the dict values are lists containing&lt;/span&gt;
&lt;span class="c1"&gt;# a tuple containing&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;# (index value of a given data point, the colspan value for given point)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In the function below, &lt;tt class="docutils literal"&gt;nested_colspan_dict&lt;/tt&gt; , the nested data structure is created by iterating over the key, value pairs in the &lt;tt class="docutils literal"&gt;colspan_dict&lt;/tt&gt; object. The key, value pairs are accessed via the &lt;tt class="docutils literal"&gt;.items()&lt;/tt&gt; method on the dictionary object. The key will remain the same and be the row number and act as the key to the new dictionary. Using the &lt;tt class="docutils literal"&gt;enumerate()&lt;/tt&gt; function on the colspan values in each row will result in a tuple containing the index of a given colspan value and the colspan value itself.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nested_colspan_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;nested_colspan_obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;colspan_tuple&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;colspan_tuple&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nested_colspan_obj&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Next, since we may need to extract data from the nested dictionary multiple times, it makes sense to create a function. This function iterates over the nested dictionary object and checks to see if a given colspan value does not equal 1. The function first iterates over the key, value pairs of the &lt;tt class="docutils literal"&gt;nested_colspan&lt;/tt&gt; object which was created with the previous function &lt;tt class="docutils literal"&gt;nested_colspan_dict&lt;/tt&gt;. Because the &lt;tt class="docutils literal"&gt;nested_colspan&lt;/tt&gt; dict values are lists containing tuples, we have to iterate over the individual tuples to access the information inside them (such as the colspan values). For any tuple, if the colspan value does not equal one, the function will yield a dictionary object which contains the row number as the key and a tuple as the dictionary value. The tuple will then be parsed for the colspan value and the index value it occurs in the row it resides.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;colspans_to_fix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nested_colspan&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;nested_colspan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;tupl&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# tuples are (colspan_index, colspan_value)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;tupl&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="c1"&gt;# key = row number&lt;/span&gt;
                &lt;span class="c1"&gt;# tuple = (index_of_cell, colspan_value_for_cell)&lt;/span&gt;
                &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tupl&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="file-writer-function"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;&lt;strong&gt;File Writer Function&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Below are commonly used lines of code in Python when doing I/O operations (see Python docs for working with &lt;a class="reference external" href="https://docs.python.org/3.7/library/csv.html"&gt;CSV files&lt;/a&gt; ). I put these basic instructions into a function to curtail redundancy. One detail to note is that in the very last line of the function, the &lt;tt class="docutils literal"&gt;.writerows&lt;/tt&gt; method accepts an iterable which will be lists of each individual data point from each row. If no row (list) is present, the row will not be written to the CSV file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# A function to write the rows to a file.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.csv&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newline&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# if row avoids blank rows&lt;/span&gt;
        &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writerows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-bulk-of-the-script"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;&lt;strong&gt;The Bulk of the Script&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The main portion of the script is a long &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop with multiple conditional statements to control the flow of the various instructions.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Below is the main script in one block of code, which I will expand on in pieces.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table_count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;headers_rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{}}&lt;/span&gt;
    &lt;span class="n"&gt;colspan&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;td_tag&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;colspan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                               &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;colspan&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;td_tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrs&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                               &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;td_tag&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_good_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
                                                   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
                                                   &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;is_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
                                                 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
                                                 &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;cells_same_colspan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; header&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;nested_cs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nested_colspan_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;bad_colspans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspans_to_fix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nested_cs&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;headers_only&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;cells_same_colspan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bad_colspans&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                    &lt;span class="n"&gt;row_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
                    &lt;span class="n"&gt;colspan_ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
                    &lt;span class="n"&gt;colspan_minus_one&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                    &lt;span class="n"&gt;index_for_insert&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;colspan_ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;row_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;headers_only&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                        &lt;span class="n"&gt;headers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_minus_one&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                            &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_for_insert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                        &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_minus_one&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                            &lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_for_insert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;colspan_ind&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; header&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-data-container-objects"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;&lt;strong&gt;The Data Container Objects&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before expanding on the &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop, I want to cover the main objects that are created for each iteration.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;table&lt;/tt&gt; : Because I previously created the &lt;tt class="docutils literal"&gt;tables&lt;/tt&gt; object, I can access each table by calling a given table's index value. In this case``i`` will be an integer, generated by the &lt;tt class="docutils literal"&gt;range()&lt;/tt&gt; function, that will be used to index each table in the list object &lt;tt class="docutils literal"&gt;tables&lt;/tt&gt; .&lt;/li&gt;
&lt;li&gt;headers_rows: This will be the main data structure that stores the data that will be written to the CSV file. The nested dictionary will have two main keys, one for header data ( &lt;tt class="docutils literal"&gt;'headers'&lt;/tt&gt; ) and another for table data ( &lt;tt class="docutils literal"&gt;'tdata'&lt;/tt&gt; ). Because this object's structure is layered, I created a small visual of the data structure below.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# headers_rows&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
 &lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;j&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;k&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;# &amp;#39;headers&amp;#39; is the key for the header dictionary and &amp;#39;tdata&amp;#39; is the key for the table dictionary.&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;#39;headers&amp;#39; contains all headers for one table and &amp;#39;tdata&amp;#39; contains all table data for one table.&lt;/span&gt;
&lt;span class="c1"&gt;# Each integer, above, represent a row number.&lt;/span&gt;
&lt;span class="c1"&gt;# Each list represents a row.&lt;/span&gt;
&lt;span class="c1"&gt;# Each letter represents a data point in a row.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;colspan: This object will be a dictionary that will store the row count as the dictionary keys and the colspan values stored as a list as the dictionary values.&lt;/li&gt;
&lt;li&gt;line_count: a simple row counter.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="part-1-iterate-over-each-table-and-each-row"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;&lt;strong&gt;Part 1: Iterate over each Table and each Row&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The for loop will iterate over a sequence of numbers generated by the &lt;tt class="docutils literal"&gt;range()&lt;/tt&gt; function. The &lt;tt class="docutils literal"&gt;table_count&lt;/tt&gt; object is just an integer that tells us how many tables to iterate over. Because table_count is equal to the number 20, &lt;tt class="docutils literal"&gt;range()&lt;/tt&gt; will produce the sequence 0-19, which will allow us to access each table. The script will start on tables[0], followed by tables[1] and so-on.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table_count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;headers_rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{}}&lt;/span&gt;
    &lt;span class="n"&gt;colspan&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;After the iteration starts processing each &lt;tt class="docutils literal"&gt;&amp;lt;table&amp;gt;&lt;/tt&gt; tag, which is full of all the table information, and the necessary data containers are created, the loop begins iterating over each table row. This is done by using BeautifulSoup's &lt;tt class="docutils literal"&gt;.findAll()&lt;/tt&gt; method which will return a list of all &lt;tt class="docutils literal"&gt;tr&lt;/tt&gt; tags.&lt;/p&gt;
&lt;p&gt;Next, the &lt;tt class="docutils literal"&gt;colspan&lt;/tt&gt; dict will be created by using the line_count, starting at 0, as the dictionary keys and a list of colspan values as the dictionary values.
A plain-spoken description of the list comprehension could be &amp;quot;for each &amp;lt;td&amp;gt; tag in all the found &amp;lt;td&amp;gt; tags, if the 'colspan' string is one of the &amp;lt;td&amp;gt; tag attributes, return the colspan value as an integer, if not, return the number 1.&amp;quot; I made it so that all &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tags have a default colspan value of 1 (meaning they span only one column).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;td_tag&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;colspan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                           &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;colspan&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;td_tag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrs&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                           &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;td_tag&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;After recording all &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tags as having a colspan of 1, except when there is an actual colspan value, the row or &amp;lt;tr&amp;gt; tag, will be passed to the boolean &lt;tt class="docutils literal"&gt;is_good_header&lt;/tt&gt; function. Also, Recall that the table layout is arranged such that there are two tables, with the same two headers, for every column. &lt;tt class="docutils literal"&gt;and i % 2 == 0&lt;/tt&gt; is a way to avoid the excess header data. If &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; is divisible by 2, meaning the integer is &lt;em&gt;even&lt;/em&gt; , then the table's headers are the program's first time to encounter a given set of headers. The odd numbered tables will contain duplicate header data and will be excluded.&lt;/p&gt;
&lt;p&gt;The nested dictionary object, &lt;tt class="docutils literal"&gt;headers_rows&lt;/tt&gt; will store all of a given table's data. &lt;tt class="docutils literal"&gt;header_rows&lt;/tt&gt; contains two keys ('headers' and 'tdata'), both of which have an empty dictionary as their values. The empty dictionaries are then populated with key value pairs. The keys for each empty dictionary will be the row number in the table, or &lt;tt class="docutils literal"&gt;line_count&lt;/tt&gt; and the values associated with each key will be a list that contains the row's data. The individual data points in a given row will be stored as string values in each list.&lt;/p&gt;
&lt;p&gt;The list comprehension ( &lt;tt class="docutils literal"&gt;for data in &lt;span class="pre"&gt;row.findAll('td')&lt;/span&gt;&lt;/tt&gt; ...) populates the values associated with the row number keys. The list comprehension is stating, &amp;quot;for each data point, encased in a row's &amp;lt;td&amp;gt; tags, if the data point is an instance of a Tag object, return the text value in the &amp;lt;td&amp;gt; tag. The &lt;tt class="docutils literal"&gt;data.font.text&lt;/tt&gt; uses BeautifulSoup's syntax where you can access a Tag's attribute like a dictionary, such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;data['font']&lt;/span&gt;&lt;/tt&gt; or via the syntax &lt;tt class="docutils literal"&gt;data.font&lt;/tt&gt;. The &lt;tt class="docutils literal"&gt;.text&lt;/tt&gt; attribute, the object's attribute not to be confused with a Tag's HTML attribute, gives the text or string value within the tag.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;line_count&lt;/tt&gt; is incremented by 1 so that each row has a unique identifier and is thus accessible as a dictionary key via indexing.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_good_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;header_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
                                          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
                                          &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Next, because the function &lt;tt class="docutils literal"&gt;is_header()&lt;/tt&gt; returns a None object when a header is &lt;em&gt;not&lt;/em&gt; found, I used the None object as a simple non-header row identifier. Similar to the block of code above, the headers_rows nested dictionary is populated with row data only this time the 'tdata' 's dictionary will be populated with the table row data, whereas before the &lt;tt class="docutils literal"&gt;headers&lt;/tt&gt; 's dictionary was populated with the table header data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;is_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;line_count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
                                        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;font&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
                                        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="n"&gt;line_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;An &lt;tt class="docutils literal"&gt;else&lt;/tt&gt; statement is also included for instances when a row, (table row or header row) does not meet the previous two criteria - a row is an odd numbered header row for instance. Finally, the simple &lt;tt class="docutils literal"&gt;write_rows()&lt;/tt&gt; function is implemented for the table's &amp;quot;good&amp;quot; (no cell alignment issues) rows and header rows. The tables are written to a CSV file and split up by their naming convention which notes the table number and whether the data is header or table data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;cells_same_colspan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; header&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This next section was pretty tricky for me. When &lt;tt class="docutils literal"&gt;cells_same_colspan()&lt;/tt&gt; returns False, meaning their is a colspan value larger than 1, then the cell alignment issue arises and must be corrected.&lt;/p&gt;
&lt;p&gt;First, the &lt;tt class="docutils literal"&gt;nested_cs&lt;/tt&gt; object uses the &lt;tt class="docutils literal"&gt;nested_colspan_dict()&lt;/tt&gt; function which associates the index values for each colspan value via the &lt;tt class="docutils literal"&gt;enumerate()&lt;/tt&gt; built-in Python function.
The &lt;tt class="docutils literal"&gt;bad_colspans&lt;/tt&gt; object is created with a list comprehension that generates a list of dictionaries that contain all the information needed to modify a given row's data points. Because &lt;tt class="docutils literal"&gt;colspans_to_fix&lt;/tt&gt; is a generator, the function must have the yielded values extracted. The extracted values that contain the information needed to modify a given row's data point will be in the form of { row_num: ( index_value_of_data, colspan_value ) } . For example a dictionary for row one, cell 9 which has a colspan value of 2 would look like &lt;tt class="docutils literal"&gt;{ 1: (9, 2)}&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;nested_cs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nested_colspan_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bad_colspans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspans_to_fix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nested_cs&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the header data and table data are handled separately, &lt;tt class="docutils literal"&gt;headers_only&lt;/tt&gt; extracts only the header data which will be referenced later.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;headers_only&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The main control flow technique I used to correct the cell alignment issues is the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop. Every time the &lt;tt class="docutils literal"&gt;cells_same_colspan()&lt;/tt&gt; value is &lt;em&gt;not&lt;/em&gt; True, the while loop iterates over the for loop that will eventually make &lt;tt class="docutils literal"&gt;cells_same_colspan()&lt;/tt&gt; return True. The for loop starts by iterating over the individual dictionaries in the &lt;tt class="docutils literal"&gt;bad_colspans&lt;/tt&gt; list and then iterating over the keys and values of each dictionary. The key-value pairs of each dictionary are accessed by using the &lt;tt class="docutils literal"&gt;.items()&lt;/tt&gt; method and &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; represent the keys and values, respectively. Recall that the dictionary's values are the row numbers or the index of the table. &lt;tt class="docutils literal"&gt;row_index&lt;/tt&gt; is assigned to for loop variable &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; . &lt;tt class="docutils literal"&gt;row_index&lt;/tt&gt; will be a unique idenifier for any row in a table because the row numbers are assigned starting with the very first header row and continue to the very last data row. Because the dictionary values are tuples, two variables are used for each tuple to unpack the tuples and assign a variable to each value in the tuple. The tuple variables are &lt;tt class="docutils literal"&gt;colspan_ind&lt;/tt&gt; (colspan index value which were created with a list comprehension that calls the &lt;tt class="docutils literal"&gt;enumerate()&lt;/tt&gt; function on every colspan value) and &lt;tt class="docutils literal"&gt;colspan_val&lt;/tt&gt; (the colspan values).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;cells_same_colspan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bad_colspans&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;colspan_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="n"&gt;row_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
            &lt;span class="n"&gt;colspan_ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Continuing down the while loop, you will see two variables with a + and - 1. Because the script is structured so that one &lt;tt class="docutils literal"&gt;&amp;lt;td&amp;gt;&lt;/tt&gt; tag will be written to one cell in excel, I gave each data point a default value of 1, unless the &amp;lt;td&amp;gt; explicitly showed, via a &amp;quot;colspan&amp;quot; attribute, that the colspan was a number greater than one. &lt;tt class="docutils literal"&gt;colspan_minus_one&lt;/tt&gt; is the colspan_val variable minus 1. I subtracted 1 because a data point with a colspan value of 4 will be off or out of line by 3 places because every data point has a default colspan value of 1. So if a data point has a colspan value of 2, it will be written to one cell, while the rows below it, because of the way the HTML is structured, will have 1 blank cell to align the data properly and account for the data point that spans 3 columns. The header needs a blank cell to line up with the rows below it. Below is an illustration that expands on the previously shown cell alignment problem, but now with the fixed result.&lt;/p&gt;
&lt;img alt="" src="/images/cell_align_fix.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Similarly I &lt;em&gt;add&lt;/em&gt; 1 to the index value of the individual data point with a colspan value greater than one. The goal is to create a number of blank columns in the row with the greater than 1 colspan value so that the number of columns matches the number of data points.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;colspan_minus_one&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;colspan_val&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;index_for_insert&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;colspan_ind&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;row_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;headers_only&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;headers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_minus_one&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_for_insert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colspan_minus_one&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_for_insert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;colspan&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;row_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;colspan_ind&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Lastly, after the cell alignment issues are taken care of, the &lt;tt class="docutils literal"&gt;write_rows()&lt;/tt&gt; function is used to write the data to a CSV file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; header&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;headers&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;write_rows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;headers_rows&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tdata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="python"></category><category term="webscraping"></category><category term="beautifulsoup"></category><category term="tutorial"></category></entry></feed>